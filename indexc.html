<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ashu-gfx Portfolio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&family=Space+Grotesk:wght@500;700&display=swap"
      rel="stylesheet"
    />

    <style>
    

      /* --- CANVAS FIX --- */
      #stage {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10;
        pointer-events: none; /* Allows clicking through to buttons */
      }
      /* --- IMAGE MAPPING --- */
      .hero-img {
        position: absolute;
        right: 10%;
        top: 20%;
        width: 300px;
        height: 400px;
      }

      .tile {
        width: 100%;
        height: 100%;
        position: relative;
      }
      .tile__image {
        width: 100%;
        height: 100%;
        object-fit: cover;
        opacity: 0; /* Hidden because Three.js renders over it */
      }
    </style>
  </head>

  <body>
    <canvas id="stage"></canvas>

    <section class="hero">
      <div class="hero-container">
        <div class="hero-img">
          <div class="tile">
            <img
              src="images/hero1.png"
              data-hover="images/hero2.png"
              class="tile__image"
              alt="Main Hero"
            />
          </div>
        </div>
      </div>
    </section>

    <script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 v_uv;
      void main() {
          v_uv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
      uniform vec2 u_mouse;
      uniform vec2 u_res;
      uniform sampler2D u_image;
      uniform sampler2D u_imagehover;
      uniform float u_time;
      varying vec2 v_uv;

      float circle(in vec2 _st, in float _radius, in float blurriness){
          vec2 dist = _st;
          return 1.-smoothstep(_radius-(_radius*blurriness), _radius+(_radius*blurriness), dot(dist,dist)*4.0);
      }

      // Simplex 3D Noise logic
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise3(vec3 v) {
          const vec2 C = vec2(1.0/6.0, 1.0/3.0);
          const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
          vec3 i  = floor(v + dot(v, C.yyy));
          vec3 x0 = v - i + dot(i, C.xxx);
          vec3 g = step(x0.yzx, x0.xyz);
          vec3 l = 1.0 - g;
          vec3 i1 = min(g.xyz, l.zxy);
          vec3 i2 = max(g.xyz, l.zxy);
          vec3 x1 = x0 - i1 + C.xxx;
          vec3 x2 = x0 - i2 + C.yyy;
          vec3 x3 = x0 - D.yyy;
          i = mod289(i);
          vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
          float n_ = 0.142857142857;
          vec3 ns = n_ * D.wyz - D.xzx;
          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
          vec4 x_ = floor(j * ns.z);
          vec4 y_ = floor(j - 7.0 * x_);
          vec4 x = x_ *ns.x + ns.yyyy;
          vec4 y = y_ *ns.x + ns.yyyy;
          vec4 h = 1.0 - abs(x) - abs(y);
          vec4 b0 = vec4(x.xy, y.xy);
          vec4 b1 = vec4(x.zw, y.zw);
          vec4 s0 = floor(b0)*2.0 + 1.0;
          vec4 s1 = floor(b1)*2.0 + 1.0;
          vec4 sh = -step(h, vec4(0.0));
          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
          vec3 p0 = vec3(a0.xy,h.x);
          vec3 p1 = vec3(a0.zw,h.y);
          vec3 p2 = vec3(a1.xy,h.z);
          vec3 p3 = vec3(a1.zw,h.w);
          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
          p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
          m = m * m;
          return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      void main() {
          vec2 res = u_res * PR;
          vec2 st = gl_FragCoord.xy / res.xy - vec2(0.5);
          st.y *= u_res.y / u_res.x;

          vec2 mouse = u_mouse * 0.5;
          vec2 circlePos = st - mouse;

          float c = circle(circlePos, 0.15, 2.0) * 2.5;

          float offx = v_uv.x + sin(v_uv.y + u_time * .1);
          float offy = v_uv.y - u_time * 0.1 - cos(u_time * .001) * .01;
          float n = snoise3(vec3(offx, offy, u_time * .1) * 8.) - 1.;

          float finalMask = smoothstep(0.4, 0.5, n + pow(c, 2.));

          vec4 image = texture2D(u_image, v_uv);
          vec4 hover = texture2D(u_imagehover, v_uv);
          gl_FragColor = mix(image, hover, finalMask);
      }
    </script>

    <script>
      class Figure {
        constructor(scene) {
          this.$image = document.querySelector('.tile__image')
          this.scene = scene
          this.loader = new THREE.TextureLoader()

          this.image = this.loader.load(this.$image.src)
          this.hover = this.loader.load(this.$image.dataset.hover)

          this.sizes = new THREE.Vector2(0, 0)
          this.offset = new THREE.Vector2(0, 0)
          this.mouse = new THREE.Vector2(0, 0)

          this.getSizes()
          this.createMesh()

          window.addEventListener('mousemove', ev => this.onMouseMove(ev))
        }

        getSizes() {
          const { width, height, top, left } =
            this.$image.getBoundingClientRect()
          this.sizes.set(width, height)
          this.offset.set(
            left - window.innerWidth / 2 + width / 2,
            -top + window.innerHeight / 2 - height / 2
          )
        }

        createMesh() {
          this.uniforms = {
            u_image: { value: this.image },
            u_imagehover: { value: this.hover },
            u_mouse: { value: this.mouse },
            u_time: { value: 0 },
            u_res: {
              value: new THREE.Vector2(window.innerWidth, window.innerHeight)
            }
          }

          this.geometry = new THREE.PlaneGeometry(1, 1, 1, 1)
          this.material = new THREE.ShaderMaterial({
            uniforms: this.uniforms,
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader:
              document.getElementById('fragmentShader').textContent,
            defines: { PR: window.devicePixelRatio.toFixed(1) },
            transparent: true
          })

          this.mesh = new THREE.Mesh(this.geometry, this.material)
          this.mesh.rotation.z = -9.54 * (Math.PI / 180);
          this.updateMeshScaleAndPosition()
          this.scene.add(this.mesh)
        }

        updateMeshScaleAndPosition() {
          this.mesh.position.set(this.offset.x, this.offset.y, 0)
          this.mesh.scale.set(this.sizes.x, this.sizes.y, 1)
        }

        onMouseMove(event) {
          gsap.to(this.mouse, {
            duration: 0.5,
            x: (event.clientX / window.innerWidth) * 2 - 1,
            y: -(event.clientY / window.innerHeight) * 2 + 1
          })
        }

        update() {
          if (this.uniforms) this.uniforms.u_time.value += 0.01
        }
      }

      class Scene {
        constructor() {
          this.canvas = document.getElementById('stage')
          this.scene = new THREE.Scene()
          this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            alpha: true,
            antialias: true
          })

          this.renderer.setPixelRatio(window.devicePixelRatio)
          this.setSize()

          const perspective = 800
          const fov =
            (180 * (2 * Math.atan(window.innerHeight / 2 / perspective))) /
            Math.PI
          this.camera = new THREE.PerspectiveCamera(
            fov,
            window.innerWidth / window.innerHeight,
            1,
            1000
          )
          this.camera.position.set(0, 0, perspective)

          this.figure = new Figure(this.scene)

          window.addEventListener('resize', () => this.onResize())
          this.update()
        }

        setSize() {
          this.width = window.innerWidth
          this.height = window.innerHeight
          this.renderer.setSize(this.width, this.height)
        }

        onResize() {
          this.setSize()
          this.camera.aspect = this.width / this.height
          this.camera.updateProjectionMatrix()

          // Re-calculate image position in DOM
          this.figure.getSizes()
          this.figure.updateMeshScaleAndPosition()
          this.figure.uniforms.u_res.value.set(this.width, this.height)
        }

        update() {
          requestAnimationFrame(() => this.update())
          this.figure.update()
          this.renderer.render(this.scene, this.camera)
        }
      }

      new Scene()
    </script>
  </body>
</html>
